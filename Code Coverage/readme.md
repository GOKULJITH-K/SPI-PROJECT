##  Code Coverage – APB-SPI Core

This folder contains the **code coverage flow** for the APB-SPI Core using **Synopsys VCS**.  
Coverage ensures that the testbench exercises **all RTL modules** thoroughly and helps identify untested code paths.

---

##  What is Code Coverage?

Code coverage measures how much of the design is exercised during simulation:

- **Line coverage** → Did each RTL line execute?  
- **Branch coverage** → Were all `if/else` and `case` branches taken?  
- **Condition coverage** → Were all boolean sub-expressions evaluated both true and false?  
- **Toggle coverage** → Did each signal toggle `0→1` and `1→0`?  
- **FSM coverage** → Were all states and transitions of finite state machines visited?  

 **Branch vs Condition**:  
- *Branch coverage* only checks which branch of an `if/else` was taken.  
- *Condition coverage* goes deeper: for `if (a && b)`, it checks both `a` and `b` toggled through true/false values, not just the combined outcome.

---

##  Toolchain

- **Simulator:** Synopsys VCS  
- **Report generation:** URG (Unified Report Generator)  
- **Interactive exploration:** Verdi  

---

##  Makefile

```makefile
# RTL and TB paths (example for baud generator)
RTL = ../rtl/spi_baud_generator.v
TB  = ../tb/spi_baud_generator_tb.v

FSDB_PATH=/home/cad/eda/SYNOPSYS/VERDI_2022/verdi/T-2022.06-SP1/share/PLI/VCS/LINUX64

help:
	@echo ===========================================================================================================================
	@echo " USAGE   	--  make <target>"
	@echo " clean   	=>  clean logs and intermediate files."
	@echo " report  	=>  generate HTML/text coverage reports with URG."
	@echo " verdi   	=>  open coverage results in Verdi GUI."
	@echo ===========================================================================================================================

clean:
	rm -rf csrc .fsdb novas_dump.log simv* simv1.daidir ucli.key verdi* novas.* cm.log vdCov* *.vdb *.urg coverage_report
	clear

report:
  vcs $(RTL) $(TB) -cm line+cond+branch+tgl+fsm
	./simv -cm line+cond+branch+tgl+fsm
	urg -dir simv.vdb 

verdi:
    vcs $(RTL) $(TB) -cm line+cond+branch+tgl+fsm
	./simv -cm line+cond+branch+tgl+fsm
	urg -dir simv.vdb 
	verdi -cov -covdir simv.vdb

````

---

##  How to Run

1. **Clean previous runs**

   ```bash
   make clean
   ```

2. ***Compile & simulate with coverage enabled and generate human-readable reports**

   ```bash
   make report
   ```

   HTML report appears under `urgReport/urgReport.html`.
3. ***Compile & simulate with coverage enabled and open interactive coverage in Verdi**

   ```bash
   make verdi
   ```

---

##  Outputs

* `simv.vdb/` → Coverage database (auto-generated by VCS).
* `urgReport/` → Reports generated by URG.
  
---

##  Coverage Results by Module

Update this table with your actual URG results after each run:

| Module                | Total | Line | Branch | Condition | Toggle | FSM  |
| --------------------- |------ | ---- | ------ | --------- | ------ | ---- |
| `spi_baud_generator`  |  93.31%    | 100%  | 100%    | 77.78%       | 95.45%    | - |
| `spi_slave_select`       |  97.77%    | 100%  | 100%    | 100%       | 91.07%    | -  |
| `spi_slave_interface`    |  95.25%  | 100%  | 100%    | 89.61%       | 86.64%    | 100% |
| `spi_shift_reg` |  -   | 100%  | 100%    | 100%       | 100%    | 100%  | - |

---

##  Individual Module Reports

Click to view module-specific coverage reports (paths generated by URG):

* [spi_baud_generator Coverage](https://gokuljith-k.github.io/baud_generator/index.html)
* [spi_slave_select Coverage](https://gokuljith-k.github.io/slave_select/)
* [spi_slave_interface Coverage](https://gokuljith-k.github.io/interface/)
* [spi_shift_reg Coverage](https://gokuljith-k.github.io/shifter/)

---
##  Coverage Waivers (Module-Specific Notes)

Certain coverage points are intentionally excluded because they are **not functionally reachable** or **not meaningful to test**.  
Below is the structured waiver documentation that can be reused for all modules.

---

### `spi_baud_generator`

####  Condition Coverage Waivers
- **Complementary CPOL/CPHA settings**  
  - In the SPI protocol, `CPOL` and `CPHA` combinations are complementary.  
  - This makes the `else` branch in certain conditions logically **unreachable**.  
  - URG flags this as uncovered, but it is **expected and acceptable**.  

####  Toggle Coverage Waivers
- **BaudRateDivisor LSB (bit[0])**  
  - Any integer multiplied by 2 (or a higher power of 2) will always result in an even number. In binary, an even number's least significant bit (bit 0) is always 0.   
  - Waived since it is a *structural property* of the divider logic.
  
- **counter_s[11] is Always Zero**

This bit fails to toggle because the counter **never reaches a number high enough** to require using its 11th bit.

* **Counter's Limit:** The counter increments until it reaches the value of `(BaudRateDivisor_o / 2) - 1`.

* **Maximum Divisor:** Let's calculate the largest possible `BaudRateDivisor_o` your inputs can produce:
    * Max `sppr_i` is `3'b111` (7). So, `(sppr_i + 1)` is 8.
    * Max `spr_i` is `3'b111` (7). So, `2**(spr_i + 1)` is `2**8`, which is 256.
    * Max `BaudRateDivisor_o` = 8 * 256 = **2048**.

* **Maximum Count Value:** Now, let's plug that into the counter's limit formula:
    * `Max Count` = (`2048 / 2`) - 1 = 1024 - 1 = **1023**.

The largest number your 12-bit counter will ever hold is 1023.

* **The Binary Representation:**
    * The number 1023 in binary is `0011 1111 1111`.
    * The number 2048 (the value needed to set the 11th bit) is `1000 0000 0000`.

Since counter's value never goes above 1023, the most significant bit, `counter_s[11]`, **will always stay at `0`**. It never has a reason to turn on, and therefore, it cannot be toggled.

### `spi_slave_select`

####  Toggle Coverage Waivers
- **`target_s[3:0]` not toggling**  
  - The slave-select logic uses a counter up to `(BaudRateDivisor/2)*16`.  
  - Because of this, the **lowest 4 bits of `target_s` never toggle** during normal operation.  
  - URG marks this as uncovered, but it is **expected and waived**.
    Of course. Let's walk through the exact numbers to show why the 15th bit of `target_s` can never be turned on.

- **`target_s[15]` not toggling**  

`assign target_s = (BaudRateDivisor_i / 2) * 16;`

### Step-by-Step with the Maximum Number

1.  **Maximum Input**
    * Your input `BaudRateDivisor_i` is a 12-bit number.
    * The largest value a 12-bit number can hold is **4095**.
    * In binary, 4095 is `1111 1111 1111`.

2.  **Step 1: Divide by 2**
    * `4095 / 2 = 2047` (using integer division, as hardware does).
    * In binary, this is like shifting the bits to the right:
        `1111 1111 1111` becomes `0111 1111 1111`.

3.  **Step 2: Multiply by 16**
    * `2047 * 16 = 32752`.
    * In binary, this is like shifting the bits 4 places to the left:
        `0111 1111 1111` becomes `0111 1111 1111 0000`.


### The Final Result

The largest possible number your logic can ever produce is **32,752**.

Let's look at this final number in the 16-bit format of `target_s`:

| Bit Position | 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
| :--- | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **Binary Value** | **0** | **1** | **1** | **1** | **1** | **1** | **1** | **1** | **1** | **1** | **1** | **1** | **0** | **0** | **0** | **0** |

As you can see, even when we use the absolute biggest input number, the **15th bit is still 0**.

Because it's impossible for your logic to calculate a number large enough to put a `1` in that 15th position, that bit will always be stuck at `0`. If it's always `0`, it can never be "toggled," which is why the coverage fails for that specific bit.

---
##  How to Interpret Coverage Reports

* **Green highlight** = Covered.
* **Red highlight** = Uncovered → add new testcases.
* **Yellow highlight** = Partially covered.

---

##  Summary

* Run `make run` → compile + simulate with coverage enabled.
* Run `make report` → generate HTML/text coverage reports.
* Run `make verdi` → analyze coverage interactively.


---
