# ðŸ”— APB-SPI Protocol Project

This repository contains the design, simulation, and implementation of an **APB-based Serial Peripheral Interface (SPI) Core**.  
The project integrates the well-known **SPI communication protocol** with the **AMBA APB bus**, making it highly suitable for use in **SoC (System-on-Chip)** and **embedded systems**.  

The work involves **RTL design in Verilog**, **verification using testbenches**, **linting with SpyGlass**, **code coverage using vcs**, and **synthesis using Synopsys DC Shell**.  
This document serves both as a **technical overview** and as a **user guide** for the project.  

---

##  1. SPI Protocol â€“ Detailed Explanation

The **Serial Peripheral Interface (SPI)** is a **synchronous serial communication protocol** developed by Motorola in the 1980s. It has since become one of the most widely adopted methods for short-distance communication between **controllers (masters)** and **peripherals (slaves)**.  

SPI is designed to be:  
- **Fast**: Supports speeds up to tens of Mbps.  
- **Simple**: Uses only four essential signals.  
- **Flexible**: Works with multiple modes and word lengths.  
- **Efficient**: Transfers data continuously with little overhead.  

### 1.1 SPI Signals
The SPI bus consists of four key signals:
- **SCLK (Serial Clock):** Clock signal generated by the master. Defines the timing of data transfers.  
- **MOSI (Master Out, Slave In):** Data sent from master to slave.  
- **MISO (Master In, Slave Out):** Data sent from slave to master.  
- **SS/CS (Slave Select / Chip Select):** Active-low signal used to select a slave device.  

### 1.2 Working Principle
The operation of SPI can be summarized as follows:
1. The master configures the communication parameters (clock polarity, clock phase, baud rate).  
2. The master selects a slave by pulling its **SS line low**.  
3. The master generates **clock pulses (SCLK)**.  
4. On each clock edge:
   - The master shifts out one data bit on **MOSI**.  
   - The slave shifts out one data bit on **MISO**.  
   - Both sample incoming data from each other.  
5. After the required number of bits (commonly 8), both devices have exchanged one complete word.  
6. The master releases the slave by setting **SS high**.  

This results in **full-duplex communication**, meaning the master and slave send and receive data simultaneously.

### 1.3 SPI Modes
SPI provides four modes of operation, determined by **Clock Polarity (CPOL)** and **Clock Phase (CPHA)**.  
This ensures compatibility with different devices that require data sampling on different edges of the clock.  

| Mode | CPOL | CPHA | Clock Idle | Data Sampled On | 
|------|------|------|-------------|-----------------|
| 0    | 0    | 0    | Low         | Rising edge     | 
| 1    | 0    | 1    | Low         | Falling edge    | 
| 2    | 1    | 0    | High        | Falling edge    | 
| 3    | 1    | 1    | High        | Rising edge     | 

---

##  2. Comparison with Other Protocols

SPI is often compared with other serial communication protocols like **IÂ²C** and **UART**. Each has unique advantages, disadvantages, and use cases.  

| Feature         | **SPI**               | **IÂ²C**                       | **UART**              |
|-----------------|----------------------|------------------------------|----------------------|
| Communication   | Synchronous, full-duplex | Synchronous, half-duplex      | Asynchronous, full-duplex |
| Wires Needed    | 4 (MOSI, MISO, SCLK, SS) | 2 (SDA, SCL)                 | 2 (TX, RX)           |
| Speed           | 1â€“100 Mbps (typical) | 100 kbps â€“ 3.4 Mbps          | Up to ~1 Mbps        |
| Multi-Slave     | Yes (with SS per slave) | Yes (addressing support)      | No (point-to-point)  |
| Distance        | Short (PCB level)    | Medium (~1 m)                 | Long (cables, RS-232)|
| Error Handling  | None built-in        | ACK/NACK support              | Optional parity bit  |
| Hardware Cost   | Low                  | Medium (requires pull-ups)    | Low                  |

 

---

##  3. Project Overview

This project implements a **custom APB-SPI Core** in Verilog.  

The objective is to create a **synthesizable and configurable SPI controller** that integrates with the **AMBA APB bus**, making it directly usable in SoC and FPGA-based designs.  

The project includes:  
- **Design of RTL modules**: interface, baud generator, slave select, shifter, and top-level.  
- **Testbenches** for simulation and functional verification.  
- **Linting** with Synopsys SpyGlass to ensure coding style and design rule compliance.  
- **Synthesis** with Synopsys DC Shell to generate a gate-level netlist.
- **Coverage reporting**: collects line, branch, toggle, condition, and FSM coverage, and generates detailed text/HTML reports using Synopsys VCS.

---

##  4. Features

- **APB3 Slave Interface** for integration with AMBA-based systems.  
- Supports all **four SPI modes (0â€“3)** via CPOL and CPHA bits.  
- Programmable **baud rate** using pre-scaler and divider registers.  
- **Master and Slave modes** selectable via control registers.  
- **Full-duplex data transfer** using MOSI and MISO lines.  
- **Interrupt support** for transfer complete and buffer empty events.  
- **Transfer-in-progress (TIP)** flag for status monitoring.  
- Configurable **MSB-first or LSB-first** data transfer.  
- Optimized for **low power** with run, wait, and stop modes.  

---

##  5. Architecture

The **APB-SPI Core** is organized into four main functional blocks:

### 5.1 APB Slave Interface
- Connects the SPI core to the **APB bus**.  
- Provides control, status, baud rate, and data registers.  
- Implements the APB FSM with states: **IDLE â†’ SETUP â†’ ENABLE**.  
- Generates control signals for other blocks based on register values.  

### 5.2 Baud Rate Generator
- Derives the SPI clock (SCLK) from the system clock (PCLK).    
- Ensures proper timing for MOSI and MISO transfers.  
- Supports **CPOL/CPHA configuration** for different SPI modes.  

### 5.3 Slave Select Generator
- Manages the **SS signal** in master mode.  
- Pulls SS low during active transfer and high afterward.  
- Generates useful status signals:
- **TIP (Transfer In Progress)**  
- **Receive_Data flag**  

### 5.4 Shifter
- Performs **parallel-to-serial** and **serial-to-parallel** data conversion.  
- Shifts out data on **MOSI** and shifts in data on **MISO**.  
- Configurable for **MSB-first** or **LSB-first** operation.  
- Synchronizes transfers with SCLK edges according to CPOL/CPHA.  

---

##  6. Implementation

The design is modular and divided into separate Verilog files:

- **`interface.v`** â†’ Implements the APB slave interface and register set.  
- **`baud.v`** â†’ Baud rate generator for SCLK.  
- **`shift.v`** â†’ Shifter for serial â†” parallel data conversion.  
- **`slave.v`** â†’ Slave select logic and TIP/Receive_Data flags.  
- **`top.v`** â†’ Integrates all modules into a single SPI core.  
- **`top_tb.v`** â†’ Testbenches for simulation and code coverage.  

### Toolchain Used
- **Simulation:** Xilinx Simulator  
- **Linting:** Synopsys SpyGlass  
- **Synthesis:** Synopsys Design Compiler (DC Shell)
- **Code Coverage:** Synopsys VCS

---

##  7. Conclusion

The **APB-SPI Core** designed in this project provides a complete, configurable, and synthesizable SPI solution for integration into **SoCs and FPGA-based embedded systems**.  

By combining the efficiency of the SPI protocol with the simplicity of the APB interface, the design enables:  
- High-speed communication with external peripherals.  
- Easy configurability through register-based control.  
- Low-power operation with support for wait and stop modes.  

This work demonstrates a **full VLSI design flow**: from specification and RTL coding, to simulation, linting, synthesis and code coverage â€” ensuring the design is ready for real hardware integration.  

---
